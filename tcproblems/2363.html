<html>
<head>
<title>Â Problem Statement for Homomorphism</title>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="10" width="100%">
           <tr>
             <td valign="top" width="100%"><img src="/i/clear.gif" alt="" width="240" height="1" border="0"><br>
               <table border="0" cellspacing="0" cellpadding="0" width="100%">
                 <tr>
                   <td colspan="7"><img src="/i/clear.gif" alt="" width="1" height="1" border="0"></td>
                 </tr>
                 <tr>
                   <td colspan="7"><img src="/i/clear.gif" alt="" width="1" height="5" border="0"></td>
                 </tr>
                 <tr>
                   
                     <td background="/i/steel_gray_bg.gif" class="statTextBig" colspan="7" height="18">&#160;Problem Statement for Homomorphism</td>
                   
                 </tr>
                 <tr>
                   <td colspan="7"><img src="/i/clear.gif" alt="" width="1" height="1" border="0"></td>
                 </tr>
                 <tr>
                   <td colspan="7"><img src="/i/clear.gif" alt="" width="1" height="1" border="0"></td>
                 </tr>
                 <tr>
                   <td class="problemText" valign="middle" align="left">
                      
              		<table><tr><td colspan="2" class="statText"><h3>Problem Statement</h3></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td><td class="statText"><p>A binary string is a non-empty finite sequence of 0's and 1's. Given two binary strings, <i>u</i> and <i>v</i>, their concatenation, <i>u</i> * <i>v</i>, is defined to be the binary string obtained by appending <i>v</i> to the end of <i>u</i>. For example, if <i>u</i> = 01100 and <i>v</i> = 110, then <i>u</i> * <i>v</i> = 01100110.</p>

<p>Consider a function, <i>h</i>, that maps binary strings to other binary strings. Suppose that for every string <i>u</i> with digits <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, ..., <i>a</i><sub>k</sub> in that order, it is true that <i>h</i>(<i>u</i>) = <i>h</i>(<i>a</i><sub>1</sub>) * <i>h</i>(<i>a</i><sub>2</sub>) *
... * <i>h</i>(<i>a</i><sub>k</sub>). Then, <i>h</i> is called a <i>non-degenerate homomorphism</i>. In general, this means that <i>h</i> is uniquely determined by the values of <i>h</i>(0) and <i>h</i>(1). For example, if <i>h</i>(0) = 001, and <i>h</i>(1) = 10, then,
<ul>
  <li>- <i>h</i>(110) = <i>h</i>(1) * <i>h</i>(1) * <i>h</i>(0) = 1010001.</li>
  <li>- <i>h</i>(00) = <i>h</i>(0) * <i>h</i>(0) = 001001.</li>
  <li>- <i>h</i>(0101) = <i>h</i>(0) * <i>h</i>(1) * <i>h</i>(0) * <i>h</i>(1) = 0011000110.</li>
</ul></p>

<p>Create a class Homomorphism that contains a method count, which is a given a String <b>u</b> and a String <b>v</b>. The method should return the number of distinct non-degenerate homomorphisms, <i>h</i>, which satisfy <i>h</i>(<b>u</b>) = <b>v</b>. If there are infinitely many such non-degenerate homomorphisms, the method should return -1.</p></td></tr><tr><td colspan="2" class="statText">&#160;</td></tr><tr><td colspan="2" class="statText"><h3>Definition</h3></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td><td class="statText"><table><tr><td class="statText">Class:</td><td class="statText">Homomorphism</td></tr><tr><td class="statText">Method:</td><td class="statText">count</td></tr><tr><td class="statText">Parameters:</td><td class="statText">String, String</td></tr><tr><td class="statText">Returns:</td><td class="statText">int</td></tr><tr><td class="statText">Method signature:</td><td class="statText">int count(String u, String v)</td></tr><tr><td colspan="2" class="statText">(be sure your method is public)</td></tr></table></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td></tr><tr><td class="statText"></td></tr><tr><td colspan="2" class="statText">&#160;</td></tr><tr><td colspan="2" class="statText"><h3>Notes</h3></td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">Two non-degenerate homomorphisms, <i>h</i> and <i>h'</i> are considered distinct if and only if <i>h</i>(<i>u</i>) is different from <i>h'</i>(<i>u</i>) for at least one binary string, <i>u</i>.</td></tr><tr><td colspan="2" class="statText">&#160;</td></tr><tr><td colspan="2" class="statText"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>u</b> and <b>v</b> will each contain between 1 and 50 characters inclusive.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">Each character in both <b>u</b> and <b>v</b> will be either '0' or '1'.</td></tr><tr><td colspan="2" class="statText">&#160;</td></tr><tr><td colspan="2" class="statText"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true" class="statText">0)</td><td class="statText"></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>&quot;10&quot;</pre></td></tr><tr><td class="statText"><pre>&quot;11001&quot;</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: 4</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">Since <i>h</i>(0) and <i>h</i>(1) cannot be empty strings, there are precisely 4 legal non-degenerate homomorphisms:
<br>
<br>
1. <i>h</i>(1) = 1 and <i>h</i>(0) = 1001.<br>
2. <i>h</i>(1) = 11 and <i>h</i>(0) = 001.<br>
3. <i>h</i>(1) = 110 and <i>h</i>(0) = 01.<br>
4. <i>h</i>(1) = 1100 and <i>h</i>(0) = 1.<br></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true" class="statText">1)</td><td class="statText"></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>&quot;00&quot;</pre></td></tr><tr><td class="statText"><pre>&quot;11111&quot;</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: 0</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">If <i>h</i> is a valid non-degenerate homomorphism, then <i>h</i>(00) = <i>h</i>(0) * <i>h</i>(0), which implies that <i>h</i>(00) has an even length. Thus, there are no non-degenerate homomorphisms satisfying <i>h</i>(00) = 11111.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true" class="statText">2)</td><td class="statText"></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>&quot;11&quot;</pre></td></tr><tr><td class="statText"><pre>&quot;00&quot;</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: -1</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">Any non-degenerate homomorphism, <i>h</i>, satisfying <i>h</i>(1) = 0 will also satisfy <i>h</i>(11) = 00. This leaves no restrictions at all on <i>h</i>(0), so there are an infinite number of such non-degenerate homomorphisms.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true" class="statText">3)</td><td class="statText"></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>&quot;001&quot;</pre></td></tr><tr><td class="statText"><pre>&quot;1010001&quot;</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: 1</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">The unique non-degenerate homomorphism, <i>h</i>, satisfying <i>h</i>(001) = 1010001 is given by <i>h</i>(0) = 10 and <i>h</i>(1) = 001.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true" class="statText">4)</td><td class="statText"></td></tr><tr><td class="statText">&#160;&#160;&#160;&#160;</td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>&quot;101&quot;</pre></td></tr><tr><td class="statText"><pre>&quot;11111111111111111111111111111111111111111111111111&quot;</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: 24</pre></td></tr><tr><td class="statText"></td></tr></table></td></tr></table><hr><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2010, TopCoder, Inc.  All rights reserved.  </p>
                      
                   </td>
                 </tr>
                 <tr>
                   <td colspan="7"><img src="/i/clear.gif" alt="" width="1" height="3" border="0"></td>
                 </tr>
                 <tr>
                   <td background="/i/steel_blue_bg.gif" class="statText" colspan="7"><img src="/i/clear.gif" alt="" width="1" height="5" border="0"></td>
                 </tr>
                 <tr>
                   <td class="statText" colspan="7"><img src="/i/clear.gif" alt="" width="1" height="16" border="0"></td>
                 </tr>
                 <tr>
                   <td class="statText" colspan="7">
                      This problem was used for:
   
   	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="/tc?module=ProblemDetail&rd=4770&pm=2363">Single Round Match 190 Round 1 - Division II, Level Three</a>
   
                   
                   </td>
                 </tr>


               </table>
             </td>
           </tr>
           <tr>
             <td width="100%"><img src="/i/clear.gif" alt="" width="1" height="10" border="0"></td>
           </tr>
         </table>
</body>
</html>
